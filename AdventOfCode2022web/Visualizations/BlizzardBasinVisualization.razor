<p>
    You have to find the shortest way from one point to another, avoiding the "blizzards".<br />
    I'm using a breadth-search algorithm here, the difficulty being that the pattern of "blizzards" changes over time.
</p>
@if (Solver != null)
{
    if (Solver.Prev != null)
    {
        var ViewBox = (xMin: -1, yMin: -1, xMax: Solver.Width + 2, yMax: Solver.Height + 2);
        <svg viewBox="@ViewBox.xMin @ViewBox.yMin @ViewBox.xMax @ViewBox.yMax" class="img-fluid">
            <defs>
                <radialGradient id="myGradient">
                    <stop offset="10%" stop-color="chartreuse" />
                    <stop offset="80%" stop-color="green" />
                </radialGradient>
                <g id="myImage">
                    <g transform="translate(0.5,0.5)">
                        <g transform="scale(.5)">
                            <circle r="0.5" fill="url('#myGradient')" />
                            <g transform="translate(0, -0.05)">
                                <g id="eye">
                                    <circle cx="0.15" r="0.13" fill="green" />
                                    <circle cx="0.15" r="0.1" fill="white" />
                                    <circle cx="0.12" r="0.05" fill="black" />
                                </g>
                                <use transform="scale(-1, 1)" href="#eye" />
                            </g>
                        </g>
                    </g>
                </g>
                <g id="blizzard">
                    <rect x="-0.2" y="-0.2" width="0.4" height="0.4" fill="gray" />
                </g>
            </defs>
            <pattern id="gridPattern" width="1" height="1" patternUnits="userSpaceOnUse">
                <rect width="1" height="1" fill="white" stroke="gray" stroke-width="0.1" />
            </pattern>
            <rect x="@ViewBox.xMin" y="@ViewBox.yMin" width="@(ViewBox.xMax-ViewBox.xMin)" height="@(ViewBox.yMax-ViewBox.yMin)" fill="grey" />
            <rect x="@(ViewBox.xMin+1)" y="@(ViewBox.yMin+1)" width="@(ViewBox.xMax-ViewBox.xMin-3)" height="@(ViewBox.yMax-ViewBox.yMin-3)" fill="url(#gridPattern)" />
            <rect x="@(Solver.Start.x-1)" y="@(Solver.Start.y-1)" width="1" height="1" fill="blue" />
            <rect x="@(Solver.Arrival.x-1)" y="@(Solver.Arrival.y-1)" width="1" height="1" fill="red" />

            @{
                var blizzards = Solver.ComputeBlizzardsPos();
                foreach (var blizzard in blizzards)
                {
                    <use href="#blizzard" x="@((blizzard.x-0.5).ToStringCSS())" y="@((blizzard.y-0.5).ToStringCSS())" />
                }
            }
            <g style="--elf-animation-duration: @(AnimationDuration * 80 / 100)ms;">
                @if (Solver.ComputingCompleted)
                {
                    var np = Solver.Prev.Single(x => x.Key.t == Solver.Minute).Key;
                    {
                        <use href="#myImage" x="@(np.x-1)" y="@(np.y-1)" />
                    }
                }
                else if (AnimationDuration == 0)
                {
                    foreach (var p in Solver.Prev.Keys.Where(p => p.t == Solver.Minute))
                    {
                        <use href="#myImage" x="@(p.x-1)" y="@(p.y-1)" />
                    }
                }
                else
                {
                    foreach (var p in Solver.Prev.Keys.Where(p => p.t == Solver.Minute))
                    {
                        var pr = Solver.Prev[p];
                        var anim = string.Empty;
                        var d = (x: p.x - pr.x, y: p.y - pr.y);
                        var style = $"--dx:{d.x}px;--dy:{d.y}px;";
                        <use href="#myImage" x="@(pr.x-1)" y="@(pr.y-1)" class="elf-move" style="@style" />
                    }
                    foreach (var p in Solver.DeadEnds!)
                    {
                        <use href="#myImage" x="@(p.x-1)" y="@(p.y-1)" class="elf-destroyed" />
                    }
                }
            </g>

        </svg>
    }
}

@code {
    [Parameter]
    public BlizzardBasin? Solver { get; set; }
    [Parameter]
    public int AnimationDuration { get; set; } = 500;
}
