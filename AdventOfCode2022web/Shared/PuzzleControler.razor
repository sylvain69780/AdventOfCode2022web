@using System.Diagnostics;
<h3>PuzzleControler</h3>
<button disabled=@IsStartProcessingForbidden @onclick=@StartPart1>Initialize Part 1</button>
<button disabled=@IsStartProcessingForbidden @onclick=@StartPart2>Initialize Part 2</button>
<button disabled=@IsMoveNextForbidden @onclick=@MoveNext>Move to next Step</button>
<button disabled=@IsMoveNextForbidden @onclick=@MoveUntilCompleted>Run all Steps</button>
<button disabled=@IsStopDisabled @onclick=@Stop>Stop</button>
@if (_isCompleted)
{
    <p class="border border-2 m-1 p-1">Ready</p>
}
<p>Step @(Parent?.SolvingStep ?? 0)</p>
<div class="row">
    <input type="range" id="delayRange" @bind="Parent!.AnimationDuration" min="0" max="5000" step="50">
    <label class="form-label" for="delayRange">Run a step every @Parent!.AnimationDuration ms</label>
</div>
<h3>Output</h3>
<pre class="display-6">@_result</pre>
@code {
    [CascadingParameter(Name = "Parent")]
    private PuzzlePageBase? Parent { get; set; }

    private IEnumerator<string>? _results;
    private string _result = string.Empty;
    private bool _isProcessing = false;
    private bool _isCompleted = true;

    private void StartPart1()
    {
        _results = Parent!.PuzzleSolution!.SolveFirstPart().GetEnumerator();
        SetAsRunning();
    }

    private void StartPart2()
    {
        _results = Parent!.PuzzleSolution!.SolveSecondPart().GetEnumerator();
        SetAsRunning();
    }

    private void SetAsRunning()
    {
        Parent!.SolvingStep = 0;
        _result = string.Empty;
        _isCompleted = false;
        NotifyParent();
    }

    private void MoveNext()
    {
        if (_results!.MoveNext())
        {
            Parent!.SolvingStep++;
            NotifyParent();
        }
        else
            SetAsCompleted();
    }

    private void SetAsCompleted()
    {
        Parent!.NotifyStateHasChanged();
        _isProcessing = false;
        _results = null;
        _isCompleted = true;
    }

    public void Stop()
    {
        _isProcessing = false;
        Parent!.NotifyStateHasChanged();
    }

    private async Task MoveUntilCompleted()
    {
        _isProcessing = true;
        var stopwatch = new Stopwatch();
        stopwatch.Start();
        var delay = Parent!.AnimationDuration;
        var solvingStep = Parent.SolvingStep;
        async Task notifyStepCompleted (int waitTime) 
        {
            Parent.SolvingStep = solvingStep;
            NotifyParent();
            await Task.Delay(delay + 100);
            stopwatch.Restart();
            delay = Parent.AnimationDuration;
        }
        while (_results!.MoveNext())
        {
            solvingStep++;
            if (delay > 0)
                await notifyStepCompleted(delay + 100);
            if (delay == 0 && stopwatch.ElapsedMilliseconds > 5000)
                await notifyStepCompleted(100);
            if (!_isProcessing)
                return;
        }
        await notifyStepCompleted(100);
        SetAsCompleted();
    }

    private void NotifyParent()
    {
        _result = _results!.Current;
        Parent!.NotifyStateHasChanged();
    }

    private bool IsStartProcessingForbidden => _isProcessing;

    private bool IsMoveNextForbidden => _results == null || _isCompleted || _isProcessing;

    private bool IsStopDisabled => !_isProcessing;
}
