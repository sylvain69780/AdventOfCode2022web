@inherits PuzzleViewBase
@using System.Diagnostics;
<h3>Puzzle Controler</h3>
<button disabled=@IsStartProcessingForbidden @onclick=@StartPart1>Initialize Part 1</button>
<button disabled=@IsStartProcessingForbidden @onclick=@StartPart2>Initialize Part 2</button>
<button disabled=@IsMoveNextForbidden @onclick=@MoveNext>Move to next Step</button>
<button disabled=@IsMoveNextForbidden @onclick=@MoveUntilCompleted>Run all Steps</button>
<button disabled=@IsStopDisabled @onclick=@Stop>Stop</button>
<p class="border border-2 m-1 p-1">@(_isCompleted ? "Click to start solving one of the the 2 parts." : "Click to run the next step, adjust the animation speed using the slider.")</p>
<p>Step @(PuzzleSolutionViewModel?.SolvingStep ?? 0)</p>
<div class="row">
    <input type="range" id="delayRange" @bind="PuzzleSolutionViewModel!.AnimationDuration" min="0" max="5000" step="50">
    <label class="form-label" for="delayRange">Run a step every @PuzzleSolutionViewModel!.AnimationDuration ms</label>
</div>
<h3>Output</h3>
<p><pre>@_result</pre></p>
@code {

    private IEnumerator<string>? _results;
    private string _result = string.Empty;
    private bool _isProcessing = false;
    private bool _isCompleted = true;

    private void StartPart1()
    {
        _results = PuzzleSolutionViewModel!.PuzzleSolution!.SolveFirstPart().GetEnumerator();
        PuzzleSolutionViewModel!.NotifyPuzzleInputNeeded();
        SetAsRunning();
    }

    private void StartPart2()
    {
        _results = PuzzleSolutionViewModel!.PuzzleSolution!.SolveSecondPart().GetEnumerator();
        PuzzleSolutionViewModel!.NotifyPuzzleInputNeeded();
        SetAsRunning();
    }

    private void SetAsRunning()
    {
        PuzzleSolutionViewModel!.SolvingStep = 0;
        _result = string.Empty;
        _isCompleted = false;
        _result = _results!.Current;
        StateHasChanged();
    }

    private void MoveNext()
    {
        if (_results!.MoveNext())
        {
            PuzzleSolutionViewModel!.NotifyPuzzleOutputReturned();
            PuzzleSolutionViewModel!.SolvingStep++;
            _result = _results!.Current;
            StateHasChanged();
        }
        else
        {
            _isProcessing = false;
            _results = null;
            _isCompleted = true;
        }
    }

    public void Stop()
    {
        _isProcessing = false;
    }

    private async Task MoveUntilCompleted()
    {
        _isProcessing = true;
        var stopwatch = new Stopwatch();
        stopwatch.Start();
        var delay = PuzzleSolutionViewModel!.AnimationDuration;
        var solvingStep = PuzzleSolutionViewModel.SolvingStep;
        async Task notifyStepCompleted(int waitTime)
        {
            PuzzleSolutionViewModel.SolvingStep = solvingStep;
            _result = _results!.Current;
            await Task.Delay(delay + 100);
            stopwatch.Restart();
            delay = PuzzleSolutionViewModel.AnimationDuration;
            StateHasChanged();
        }
        while (_results!.MoveNext())
        {
            PuzzleSolutionViewModel!.NotifyPuzzleOutputReturned();
            solvingStep++;
            if (delay > 0)
                await notifyStepCompleted(delay + 100);
            if (delay == 0 && stopwatch.ElapsedMilliseconds > 5000)
                await notifyStepCompleted(100);
            if (!_isProcessing)
                return;
        }
        await notifyStepCompleted(100);
        _isProcessing = false;
        _results = null;
        _isCompleted = true;
    }

    private bool IsStartProcessingForbidden => _isProcessing;

    private bool IsMoveNextForbidden => _results == null || _isCompleted || _isProcessing;

    private bool IsStopDisabled => !_isProcessing;
}
