@page "/BlizzardBasinPage"
@using System.Timers;
@inherits PuzzleSolutionPageBase<BlizzardBasinSolution>
<h2>Blizzard Basin</h2>
<div class="row">
    <div class="col-lg-6">
        @if (_previousStep != SolvingStep)
        {
            SetTimer();
        }
        <h3>Visualization of the solution</h3>
        <p>
            You have to find the shortest way from one point to another, avoiding the "blizzards".<br />
            I'm using a breadth-search algorithm here, the difficulty being that the pattern of "blizzards" changes over time.
        </p>
        @if (IsPuzzleValid)
        {
            var (gridWidth, gridHeight) = (GridWidth - 2, GridHeight - 2);
            <svg viewBox="0 0 @GridWidth @GridHeight" class="img-fluid">
                <defs>
                    <radialGradient id="elf-skin-gradient">
                        <stop offset="10%" stop-color="chartreuse" />
                        <stop offset="80%" stop-color="green" />
                    </radialGradient>
                    <g id="elf-possible">
                        <g transform="translate(0.5,0.5)">
                            <g transform="scale(.5)">
                                <circle r="0.5" fill="url('#elf-skin-gradient')" />
                                <g transform="translate(0, -0.05)">
                                    <g id="eye">
                                        <circle cx="0.15" r="0.13" fill="green" />
                                        <circle cx="0.15" r="0.1" fill="white" />
                                        <circle cx="0.12" r="0.05" fill="black" />
                                    </g>
                                    <use transform="scale(-1, 1)" href="#eye" />
                                </g>
                            </g>
                        </g>
                    </g>
                    <g id="blizzard">
                        <path d="M 0,0 -0.1,-0.2 0.2,0 -0.1,0.2 0,0" fill="gray" />
                    </g>
                    <g id="blizzard-right">
                        <use href="#blizzard" transform="translate(0.75,0.25)" />
                    </g>
                    <g id="blizzard-left">
                        <use href="#blizzard" transform="translate(0.25,0.75) rotate(180)" />
                    </g>
                    <g id="blizzard-down">
                        <use href="#blizzard" transform="translate(0.75,0.75) rotate(90) " />
                    </g>
                    <g id="blizzard-up">
                        <use href="#blizzard" transform="translate(0.25,0.25) rotate(-90) " />
                    </g>
                </defs>
                <pattern id="gridPattern" width="1" height="1" patternUnits="userSpaceOnUse">
                    <rect width="1" height="1" fill="white" stroke="gray" stroke-width="0.1" />
                </pattern>
                <rect x="0" y="0" width=@GridWidth height=@GridHeight fill="grey" />
                <rect x="1" y="1" width=@(GridWidth-2) height=@(GridHeight-2) fill="url(#gridPattern)" />
                <rect x=@Entrance.X y=@Entrance.Y width="1" height="1" fill="PaleGreen" stroke-width="0.1" stroke="green" />
                <rect x=@Exit.X y=@Exit.Y width="1" height="1" fill="PaleGreen" stroke-width="0.1" stroke="green" />
                <g style=@AnimationTimingStyle>
                    <g class=@ElfSearchClass>
                        @foreach (var child in Tree[RoundNumber])
                        {
                            var parent = RoundNumber > 0 ? Tree[RoundNumber - 1][child.ParentId] : Tree[0][0];
                            <use href="#elf-possible" style=@($"--dax:{parent.Pos.X}px;--day:{parent.Pos.Y}px;--dbx:{child.Pos.X }px;--dby:{child.Pos.Y}px;") />
                        }
                    </g>
                    <g class=@ElfKilledClass>
                        @if (RoundNumber > 0)
                        {
                            var parentIds = Tree[RoundNumber].Select(x => x.ParentId).ToHashSet();
                            for (var parentId = 0; parentId < Tree[RoundNumber - 1].Count; parentId++)
                            {
                                if (parentIds.Contains(parentId))
                                    continue;
                                var parent = Tree[RoundNumber - 1][parentId];
                                <use href="#elf-possible" style=@($"--dbx:{parent.Pos.X }px;--dby:{parent.Pos.Y}px;") />
                            }
                        }
                    </g>
                    <g class=@BlizzardClass>
                        @foreach (var b in PuzzleSolution!.BlizzardsPositions!)
                        {
                            if (b.Direction == Directions.Right)
                            {
                                <use href="#blizzard-right" style=@($"--dax:{b.Position.X-1}px;--day:{b.Position.Y}px;--dbx:{b.Position.X }px;--dby:{b.Position.Y}px;") />
                                if (b.Position.X == 1)
                                {
                                    <use href="#blizzard-right" style=@($"--dax:{gridWidth}px;--day:{b.Position.Y}px;--dbx:{gridWidth+1}px;--dby:{b.Position.Y}px;") />
                                }
                            }
                            if (b.Direction == Directions.Left)
                            {
                                <use href="#blizzard-left" style=@($"--dax:{b.Position.X+1}px;--day:{b.Position.Y}px;--dbx:{b.Position.X }px;--dby:{b.Position.Y}px;") />
                                if (b.Position.X == gridWidth)
                                {
                                    <use href="#blizzard-left" style=@($"--dax:1px;--day:{b.Position.Y}px;--dbx:0px;--dby:{b.Position.Y}px;") />
                                }
                            }
                            if (b.Direction == Directions.Down)
                            {
                                <use href="#blizzard-down" style=@($"--dax:{b.Position.X}px;--day:{b.Position.Y-1}px;--dbx:{b.Position.X}px;--dby:{b.Position.Y}px;") />
                                if (b.Position.Y == 1)
                                {
                                    <use href="#blizzard-down" style=@($"--dax:{b.Position.X}px;--day:{gridHeight}px;--dbx:{b.Position.X}px;--dby:{gridHeight+1}px;") />
                                }
                            }
                            if (b.Direction == Directions.Up)
                            {
                                <use href="#blizzard-up" style=@($"--dax:{b.Position.X}px;--day:{b.Position.Y+1}px;--dbx:{b.Position.X}px;--dby:{b.Position.Y}px;") />
                                if (b.Position.Y == gridHeight)
                                {
                                    <use href="#blizzard-up" style=@($"--dax:{b.Position.X}px;--day:1px;--dbx:{b.Position.X }px;--dby:0px;") />
                                }
                            }
                        }
                    </g>
                </g>
            </svg>
        }

    </div>
    <div class="col-lg-6">
        <PuzzleSolutionViewer Page=@this />
    </div>
</div>

@code {
    private Timer _animationTimer = new();
    private bool _animationCompleted = true;
    private int _previousStep = 0;

    protected override void OnInitialized()
    {
        _animationTimer.Elapsed += (object? sender, System.Timers.ElapsedEventArgs e) => StopAnimation();
        base.OnInitialized();
    }

    private void StopAnimation()
    {
        _animationCompleted = true;
        _animationTimer.Stop();
        StateHasChanged();
    }

    private void SetTimer()
    {
        _previousStep = SolvingStep;
        _animationTimer.Interval = AnimationDuration * 90 / 100 + 1;
        _animationTimer.Start();
        _animationCompleted = false;
    }

    private (int X, int Y) Exit => PuzzleSolution!.ExitPosition;
    private (int X, int Y) Entrance => PuzzleSolution!.EntrancePosition;
    private int RoundNumber => PuzzleSolution!.CurrentMinute;
    private List<List<(int ParentId, (int X, int Y) Pos)>> Tree => PuzzleSolution!.Tree;
    private int GridWidth => PuzzleSolution!.GridWidth;
    private int GridHeight => PuzzleSolution!.GridHeight;
    private string AnimationTimingStyle => $"--animation-duration: {AnimationDuration}ms;";
    private string ElfSearchClass => (_animationCompleted ? "elf-motionless" : "elf-moving");
    private string ElfKilledClass => (_animationCompleted ? "elf-hidden" : "elf-killed");
    private string BlizzardClass => (_animationCompleted ? "blizzard-motionless" : "blizzard-moving");
    private bool IsPuzzleValid => PuzzleSolution != null && PuzzleSolution.Tree != null && PuzzleSolution.Tree.Count > 0;
}
