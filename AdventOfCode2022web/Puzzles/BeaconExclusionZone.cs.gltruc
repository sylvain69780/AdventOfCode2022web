using GlmSharp;
using System.Text.RegularExpressions;

namespace AdventOfCode2022web.Puzzles
{
    [Puzzle(15, "Beacon Exclusion Zone")]
    public class BeaconExclusionZone : IPuzzleSolver
    {
        private class SensorPositionAndClosestBeacon
        {
            public ivec2 Sensor;
            public ivec2 Beacon;
            public int ManhattanDistance;
        }

        private static int ManhattanDistance(ivec2 a, ivec2 b) => Math.Abs(a.x - b.x) + Math.Abs(a.y - b.y);

        private static List<SensorPositionAndClosestBeacon> GetSensorPositionAndClosestBeacons(string puzzleInput)
        {
            var coordinatesRegex = new Regex(@"x=(-?\d+), y=(-?\d+)", RegexOptions.Compiled);
            return puzzleInput.Split("\n")
                .Select(x => coordinatesRegex.Matches(x))
                .Select(x => new
                {
                    Sensor = new ivec2(int.Parse(x[0].Groups[1].Value),int.Parse(x[0].Groups[2].Value)),
                    Beacon = new ivec2(int.Parse(x[1].Groups[1].Value),int.Parse(x[1].Groups[2].Value)),
                })
                .Select(x => new SensorPositionAndClosestBeacon
                {
                    Sensor = x.Sensor,
                    Beacon = x.Beacon,
                    ManhattanDistance = ManhattanDistance(x.Sensor, x.Beacon)
                })
                .ToList();
        }

        public string SolveFirstPart(string puzzleInput)
        {
            var sensorsPositionsAndClosestBeacon = GetSensorPositionAndClosestBeacons(puzzleInput);
            var verticalPositionOfRowToAnalyze = sensorsPositionsAndClosestBeacon.Count <= 14 ? 10 : 2000000;
            var horizontalIntervalsOnRowToAnalyze = new List<(int begin, int end)>();
            foreach (var record in sensorsPositionsAndClosestBeacon)
            {
                var distanceOfSensorToRowToAnalyze = Math.Abs(record.Sensor.y - verticalPositionOfRowToAnalyze);
                if (distanceOfSensorToRowToAnalyze <= record.ManhattanDistance)
                {
                    var d = record.ManhattanDistance - distanceOfSensorToRowToAnalyze;
                    horizontalIntervalsOnRowToAnalyze.Add((record.Sensor.x - d, record.Sensor.x + d));
                }
            }
            var start = horizontalIntervalsOnRowToAnalyze.Select(x => x.begin).Min();
            var end = horizontalIntervalsOnRowToAnalyze.Select(x => x.end).Max();
            var score = 0;
            var discard = sensorsPositionsAndClosestBeacon
                .Select(x => (x.Beacon.x, x.Beacon.y))
                .Concat(sensorsPositionsAndClosestBeacon
                .Select(x => (x.Sensor.x, x.Sensor.y)))
                .ToHashSet();
            for (var x = start; x <= end; x++)
            {
                var p = (x, y: verticalPositionOfRowToAnalyze);
                if (discard.Contains(p)) continue;
                foreach (var inter in horizontalIntervalsOnRowToAnalyze)
                {
                    if (x >= inter.begin && x <= inter.end)
                    {
                        score++;
                        break;
                    }
                }
            }
            return score.ToString();
        }
        public string SolveSecondPart(string puzzleInput)
        {
            var sensorsPositionsAndClosestBeacon = GetSensorPositionAndClosestBeacons(puzzleInput);
            var discard = sensorsPositionsAndClosestBeacon
                .Select(x => (x.Beacon.x, x.Beacon.y))
                .Concat(sensorsPositionsAndClosestBeacon
                .Select(x => (x.Sensor.x, x.Sensor.y)))
                .ToHashSet();
            var squares = new Queue<ivec4>();
            var mapMaxSize = sensorsPositionsAndClosestBeacon.Count <= 14 ? 20 : 4000000;
            var maxIterations = (int)Math.Sqrt(mapMaxSize) + 3;
            squares.Enqueue(new ivec4(0, 0, mapMaxSize, mapMaxSize));
            do
            {
                var smallerSquares = new Queue<ivec4>();
                while (squares.Count > 0)
                {
                    var square = squares.Dequeue();
                    var isFullyCoveredBySensor = sensorsPositionsAndClosestBeacon
                        .Any(x => ManhattanDistance(x.Sensor, square.swizzle.xy) <= x.ManhattanDistance
                            && ManhattanDistance(x.Sensor, square.swizzle.xw) <= x.ManhattanDistance
                            && ManhattanDistance(x.Sensor, square.swizzle.zy) <= x.ManhattanDistance
                            && ManhattanDistance(x.Sensor, square.swizzle.zw) <= x.ManhattanDistance);
                    if (!isFullyCoveredBySensor)
                    {
                        var width = square.swizzle.zw - square.xy;
                        var firstHalf = width /2;
                        var secondHalf = width - firstHalf;
                        if (width == new vec2(0, 0))
                            if (!discard.Contains((square.x, square.y))) 
                                smallerSquares.Enqueue(square);
                            else
                            {
                                smallerSquares.Enqueue(square + new ivec4(0,0,firstHalf.x,firstHalf.y));
                                smallerSquares.Enqueue(square + new ivec4(secondHalf.x, 0, width.x, firstHalf.y));
                                smallerSquares.Enqueue(square + new ivec4(secondHalf.x, secondHalf.y, width.x, width.y));
                                smallerSquares.Enqueue(square + new ivec4(0, secondHalf.y, 0, width.y));
                            }
                    }
                }
                squares = smallerSquares;
            } while (squares.Count > 1 && maxIterations-- != 0);
            var res = squares.Dequeue();
            // too big for int
            return ((long)res.x * 4000000 + res.y).ToString();
        }
    }
}