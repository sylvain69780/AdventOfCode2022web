@inherits PuzzleViewBase
<h3>BlizzardBasinView</h3>
<p>
    You have to find the shortest way from one point to another, avoiding the "blizzards".<br />
    I'm using a breadth-search algorithm here, the difficulty being that the pattern of "blizzards" changes over time.
</p>
@if (PuzzleSolution != null && PuzzleSolution.Prev != null)
{
    var ViewBox = (xMin: -1, yMin: -1, xMax: PuzzleSolution.Width + 2, yMax: PuzzleSolution.Height + 2);
    <svg viewBox="@ViewBox.xMin @ViewBox.yMin @ViewBox.xMax @ViewBox.yMax" class="img-fluid">
        <defs>
            <radialGradient id="myGradient">
                <stop offset="10%" stop-color="chartreuse" />
                <stop offset="80%" stop-color="green" />
            </radialGradient>
            <g id="myImage">
                <g transform="translate(0.5,0.5)">
                    <g transform="scale(.5)">
                        <circle r="0.5" fill="url('#myGradient')" />
                        <g transform="translate(0, -0.05)">
                            <g id="eye">
                                <circle cx="0.15" r="0.13" fill="green" />
                                <circle cx="0.15" r="0.1" fill="white" />
                                <circle cx="0.12" r="0.05" fill="black" />
                            </g>
                            <use transform="scale(-1, 1)" href="#eye" />
                        </g>
                    </g>
                </g>
            </g>
            <g id="blizzard">
                <rect x="-0.2" y="-0.2" width="0.4" height="0.4" fill="gray" />
            </g>
        </defs>
        <pattern id="gridPattern" width="1" height="1" patternUnits="userSpaceOnUse">
            <rect width="1" height="1" fill="white" stroke="gray" stroke-width="0.1" />
        </pattern>
        <rect x="@ViewBox.xMin" y="@ViewBox.yMin" width="@(ViewBox.xMax-ViewBox.xMin)" height="@(ViewBox.yMax-ViewBox.yMin)" fill="grey" />
        <rect x="@(ViewBox.xMin+1)" y="@(ViewBox.yMin+1)" width="@(ViewBox.xMax-ViewBox.xMin-3)" height="@(ViewBox.yMax-ViewBox.yMin-3)" fill="url(#gridPattern)" />
        <rect x="@(PuzzleSolution.Start.x-1)" y="@(PuzzleSolution.Start.y-1)" width="1" height="1" fill="blue" />
        <rect x="@(PuzzleSolution.Arrival.x-1)" y="@(PuzzleSolution.Arrival.y-1)" width="1" height="1" fill="red" />

        <g style="--elf-animation-duration: @(AnimationDuration)ms;">
            <g class=@(_animationCompleted ? "elf-still" : "elf-move" )>
                @{
                    foreach (var p in PuzzleSolution!.Prev!.Keys.Where(p => p.t == PuzzleSolution.Minute))
                    {
                        var pr = _animationCompleted ? p : PuzzleSolution.Prev[p];
                        var style = $"--dax:{pr.x - 1}px;--day:{pr.y - 1}px;--dbx:{p.x - 1}px;--dby:{p.y - 1}px;";
                        <use href="#myImage" style=@style />
                    }
                }
            </g>
            <g class=@(_animationCompleted ? "elf-hidden" : "elf-destroyed" )>
                @{
                    if (PuzzleSolution.DeadEnds != null && PuzzleSolution.DeadEnds.Count > 0)
                        foreach (var p in PuzzleSolution.DeadEnds)
                        {
                            var style = $"--dax:{p.x - 1}px;--day:{p.y - 1}px;--dbx:{p.x - 1}px;--dby:{p.y - 1}px;";
                            <use href="#myImage" style=@style />
                        }
                }
            </g>
            <g>
                @{
                    var blizzards = PuzzleSolution.ComputeBlizzardsPos();
                    foreach (var blizzard in blizzards)
                    {
                        <g class=@(_animationCompleted?"blizzard-hidden":"blizzard")>
                            <use href="#blizzard" x="@((blizzard.x-0.5).ToStringCSS())" y="@((blizzard.y-0.5).ToStringCSS())" />
                        </g>
                    }
                }
            </g>
        </g>

    </svg>
}
@if (_animationCompleted)
{
    <p>Animation Stopped</p>
}
else
{
    <p>Animation Running</p>
}

@code {
    private BlizzardBasin? PuzzleSolution;

    protected override void OnInitialized()
    {
        PuzzleSolution = (BlizzardBasin)(PuzzleSolutionViewModel!.PuzzleSolution!);
        PuzzleSolutionViewModel.PuzzleOutputReturned += SetTimer;
        base.OnInitialized();
    }

    public void Dispose()
    {
        PuzzleSolutionViewModel!.PuzzleOutputReturned -= SetTimer;
    }

    private Timer? _timer;
    private bool _animationCompleted = true;

    private void SetTimer()
    {
        _timer = new Timer(Callback, null, PuzzleSolutionViewModel!.AnimationDuration, Timeout.Infinite);
        _animationCompleted = false;
        StateHasChanged();
    }

    private void Callback(object? state)
    {
        _animationCompleted = true;
        StateHasChanged();
    }
}
