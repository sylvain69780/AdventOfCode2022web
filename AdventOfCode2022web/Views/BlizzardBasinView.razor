@inherits PuzzleViewBase
<h3>BlizzardBasinView</h3>
<p>
    You have to find the shortest way from one point to another, avoiding the "blizzards".<br />
    I'm using a breadth-search algorithm here, the difficulty being that the pattern of "blizzards" changes over time.
</p>
@if (PuzzleSolution != null && PuzzleSolution.Prev != null)
{
    <svg viewBox="@ViewBox.Min.X @ViewBox.Min.Y @ViewBox.Max.X @ViewBox.Max.Y" class="img-fluid">
        <BlizzardBasinViewDefs/>
        <rect x="@ViewBox.Min.X" y="@ViewBox.Min.Y" width="@(ViewBox.Max.X-ViewBox.Min.X)" height="@(ViewBox.Max.Y-ViewBox.Min.Y)" fill="grey" />
        <rect x="@(ViewBox.Min.X+1)" y="@(ViewBox.Min.Y+1)" width="@(ViewBox.Max.X-ViewBox.Min.X-3)" height="@(ViewBox.Max.Y-ViewBox.Min.Y-3)" fill="url(#gridPattern)" />
        <rect x="@(Entrance.X)" y="@(Entrance.Y)" width="1" height="1" fill="blue" />
        <rect x="@(Exit.X)" y="@(Exit.Y)" width="1" height="1" fill="red" />

        <g style="--elf-animation-duration: @(AnimationDuration)ms;">
            <g class=@(_animationCompleted ? "elf-still" : "elf-move")>
                @foreach (var elf in PuzzleSolution!.Elves!.Where(x => x.State == BlizzardBasinElfState.Possible))
                {
                    <use href="#elf-possible" style=@($"--dax:{elf.StartingPosition.X - 1}px;--day:{elf.StartingPosition.Y - 1}px;--dbx:{elf.TargetPosition.X - 1}px;--dby:{elf.TargetPosition.Y - 1}px;") />
                }
            </g>
            @*            <g class=@(_animationCompleted ? "elf-hidden" : "elf-destroyed" )>
        @{
        if (PuzzleSolution.DeadEnds != null && PuzzleSolution.DeadEnds.Count > 0)
        foreach (var p in PuzzleSolution.DeadEnds)
        {
        var style = $"--dax:{p.x - 1}px;--day:{p.y - 1}px;--dbx:{p.x - 1}px;--dby:{p.y - 1}px;";
        <use href="#myImage" style=@style />
        }
        }
        </g>
        *@
        @*<g>
                @{
                    var blizzards = PuzzleSolution.ComputeBlizzardsPos();
                    foreach (var blizzard in blizzards)
                    {
                        <g class=@(_animationCompleted?"blizzard-hidden":"blizzard")>
                            <use href="#blizzard" x="@((blizzard.x-0.5).ToStringCSS())" y="@((blizzard.y-0.5).ToStringCSS())" />
                        </g>
                    }
                }
            </g>*@
        </g>

    </svg>
}
@if (_animationCompleted)
{
    <p>Animation Stopped</p>
}
else
{
    <p>Animation Running</p>
}

@code {
    private BlizzardBasin? PuzzleSolution;

    protected override void OnInitialized()
    {
        PuzzleSolution = (BlizzardBasin)(PuzzleSolutionViewModel!.PuzzleSolution!);
        PuzzleSolutionViewModel.PuzzleOutputReturned += SetTimer;
        base.OnInitialized();
    }

    public void Dispose()
    {
        PuzzleSolutionViewModel!.PuzzleOutputReturned -= SetTimer;
    }

    private Timer? _timer;
    private bool _animationCompleted = true;

    private void SetTimer()
    {
        _timer = new Timer(Callback, null, PuzzleSolutionViewModel!.AnimationDuration, Timeout.Infinite);
        _animationCompleted = false;
        StateHasChanged();
    }

    private void Callback(object? state)
    {
        _animationCompleted = true;
        StateHasChanged();
    }

    private (int X, int Y) Exit => PuzzleSolution!.ExitPosition;
    private (int X, int Y) Entrance => PuzzleSolution!.EntrancePosition;
    private ((int X, int Y) Min, (int X, int Y) Max) ViewBox => ((-1,-1),(PuzzleSolution!.GridWidth + 2, yMax: PuzzleSolution.GridHeight + 2));
}
