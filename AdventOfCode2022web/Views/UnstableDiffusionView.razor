@inherits PuzzleViewBase
<p>We need to simulate the diffusion of strangely behaving particules.</p>
@if ((_solver != null))
{
    if (_solver.Elves.Length > 0)
    {
        SetTimer();
        var positions = _solver.Elves;
        var prevPositions = _solver.ElvesPrevPosition;
        foreach (var p in positions)
        {
            if (p.X < ViewBox.xMin)
                ViewBox.xMin *= 2;
            if (p.Y < ViewBox.yMin)
                ViewBox.yMin *= 2;
            if (p.X >= ViewBox.xMax)
                ViewBox.xMax *= 2;
            if (p.Y >= ViewBox.yMax)
                ViewBox.yMax *= 2;
        }
        <svg viewBox="@ViewBox.xMin @ViewBox.yMin @ViewBox.xMax @ViewBox.yMax" class="img-fluid">
            <defs>
                <radialGradient id="myGradient">
                    <stop offset="10%" stop-color="chartreuse" />
                    <stop offset="80%" stop-color="green" />
                </radialGradient>
            </defs>
            <pattern id="gridPattern" width="1" height="1" patternUnits="userSpaceOnUse">
                <rect width="1" height="1" fill="white" stroke="gray" stroke-width="0.1" />
            </pattern>
            <rect x="@ViewBox.xMin" y="@ViewBox.yMin" width="@(ViewBox.xMax-ViewBox.xMin)" height="@(ViewBox.yMax-ViewBox.yMin)" fill="url(#gridPattern)" />
            <g visibility="hidden">
                <g id="myImage">
                    <g transform="translate(0.5,0.5)">
                        <circle r="0.5" fill="url('#myGradient')" />
                        <g transform="translate(0, -0.05)">
                            <g id="eye">
                                <circle cx="0.15" r="0.13" fill="green" />
                                <circle cx="0.15" r="0.1" fill="white" />
                                <circle cx="0.12" r="0.05" fill="black" />
                            </g>
                            <use transform="scale(-1, 1)" href="#eye" />
                        </g>
                    </g>
                </g>
            </g>
            @if (AnimationDuration > 0 && !_animationCompleted)
            {
                var style = $"animation-duration : {AnimationDuration * 80 / 100}ms;";
                for (var i = 0; i < positions.Length; i++)
                {
                    var p = prevPositions[i];
                    var pp = positions[i];
                    var d = (pp.X - p.X, pp.Y - p.Y);
                    var anim = string.Empty;
                    if (AnimationDuration > 0)
                    {
                        if (d == (1, 0))
                            anim = "elf-move-right";
                        if (d == (-1, 0))
                            anim = "elf-move-left";
                        if (d == (0, 1))
                            anim = "elf-move-down";
                        if (d == (0, -1))
                            anim = "elf-move-up";
                        <use href="#myImage" x="@(p.X)" y="@(p.Y)" class="@anim" style="@style" />
                    }
                }
            }
            else
            {
                for (var i = 0; i < positions.Length; i++)
                {
                    var pp = positions[i];
                    <use href="#myImage" x="@(pp.X)" y="@(pp.Y)" />
                }
            }
        </svg>
        @if (_animationCompleted)
        {
            <p>Animation Stopped</p>
        }
        else
        {
            <p>Animation Stopped</p>
        }
    }
}

@code {

    private UnstableDiffusion? _solver => (UnstableDiffusion)(Parent!.PuzzleSolution!);

    (int xMin, int yMin, int xMax, int yMax) ViewBox = (-4, -4, 4, 4);

    private int _previousSolingStep = 0;
    private Timer? _timer;
    private bool _animationCompleted = true;

    private void SetTimer()
    {
        if (Parent!.SolvingStep == _previousSolingStep)
            return;
        _timer = new Timer(Callback, null, AnimationDuration, Timeout.Infinite);
        _previousSolingStep = Parent.SolvingStep;
        _animationCompleted = false;
    }
    private void Callback(object? state)
    {
        _animationCompleted = true;
        StateHasChanged();
    }
}
